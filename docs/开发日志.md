## 2025.04.16

确定了基本的微服务架构，包含8个微服务

#### 费用查询服务

- 按就诊编号和患者编号查询
- 查看诊断详情
- 查看治疗详情
- 分页功能

## 2025.04.19

架构上将网关服务和用户认证服务合并，变为7个微服务

#### 费用查询服务

- 增加定点医疗机构字段
- 增加按医疗类别查询

> 问题："Connection leak detection triggered"和"Statement cancelled due to timeout"，连接泄漏与查询超时
>
> 解决：在MySQL为结算信息表手动创建索引，在JPA实体中保持索引定义维护代码与数据库结构的一致性

> 问题：前端未接受到医疗机构字段信息
>
> 解决：使用Lombok为实体类自动生成getter方法 

## 2025.04.20

#### 费用查询服务

- 使用Redis缓存提升查询效率

> 问题：Page对象在Redis缓存中无法正确序列化/反序列化
>
> 尝试：不直接缓存Page对象，而是分别缓存其组成部分List\<Settlement\>,再在服务层重新组装成Page对象 —>
>
> ​			方法内部调用（通过this）带@Cacheable注解的其他方法时，Spring AOP无法拦截这些调用
>
> 解决：使用AopContext.currentProxy()获取代理对象（通过proxy）来调用缓存方法

## 2025.04.21

#### API网关服务

- 用户登录认证，生成JWT令牌
- 从JWT中提取用户信息（角色，医院代码），通过请求头将用户上下文信息传递给费用查询服务

#### 费用查询服务

- 根据用户信息查询，相应Redis逻辑修改（增加用户信息为key）

> **登录逻辑**
>
> 用户 -> 前端: 输入用户名密码
> 前端 -> API网关: POST /api/auth/login
> API网关 -> AuthController: 处理登录请求
> AuthController -> JwtUtil: 生成JWT令牌(包含用户信息)
> JwtUtil -> AuthController: 返回JWT令牌
> AuthController -> API网关: 返回包含令牌的响应
> API网关 -> 前端: 返回JWT令牌
> 前端: 保存令牌到localStorage

> **查询逻辑**
>
> 用户 -> 前端: 发起查询请求
> 前端 -> API网关: 请求携带JWT令牌(Authorization头)
> API网关 -> JwtAuthenticationFilter: 拦截并验证令牌
> JwtAuthenticationFilter: 解析令牌获取用户信息，将用户信息添加到自定义请求头
> API网关 -> 费用查询服务: 转发带有用户信息的请求
> 费用查询服务 -> RequestInterceptor: 拦截请求
> RequestInterceptor: 从请求头提取用户信息
> RequestInterceptor -> UserContext: 设置用户信息到线程上下文
> 费用查询服务 -> SettlementController: 处理查询请求
> SettlementController -> SettlementService: 调用业务逻辑
> SettlementService: 从UserContext获取用户信息，根据用户角色应用数据过滤
> SettlementService -> 数据库: 执行带有权限过滤的查询
> 数据库 -> SettlementService: 返回查询结果
> SettlementService -> SettlementController: 返回处理后的数据
> 费用查询服务 -> API网关: 返回响应
> API网关 -> 前端: 返回最终数据

