## 2025.04.16

确定了基本的微服务架构，包含8个微服务

#### 费用查询服务

- 按就诊编号和患者编号查询
- 查看诊断详情
- 查看治疗详情
- 分页功能

## 2025.04.19

架构上将网关服务和用户认证服务合并，变为7个微服务

#### 费用查询服务

- 增加定点医疗机构字段
- 增加按医疗类别查询

> 问题："Connection leak detection triggered"和"Statement cancelled due to timeout"，连接泄漏与查询超时
>
> 解决：在MySQL为结算信息表手动创建索引，在JPA实体中保持索引定义维护代码与数据库结构的一致性

> 问题：前端未接受到医疗机构字段信息
>
> 解决：使用Lombok为实体类自动生成getter方法 

## 2025.04.20

#### 费用查询服务

- 使用Redis缓存提升查询效率

> 问题：Page对象在Redis缓存中无法正确序列化/反序列化
>
> 尝试：不直接缓存Page对象，而是分别缓存其组成部分List\<Settlement\>,再在服务层重新组装成Page对象 —>
>
> ​			方法内部调用（通过this）带@Cacheable注解的其他方法时，Spring AOP无法拦截这些调用
>
> 解决：使用AopContext.currentProxy()获取代理对象（通过proxy）来调用缓存方法

## 2025.04.24

#### API网关服务

- 用户登录认证，生成JWT令牌
- 从JWT中提取用户信息（角色，医院代码），通过请求头将用户上下文信息传递给费用查询服务

#### 费用查询服务

- 根据用户信息查询，相应Redis逻辑修改（增加用户信息为key）

> **登录逻辑**
>
> 用户 -> 前端: 输入用户名密码
> 前端 -> API网关: POST /api/auth/login
> API网关 -> AuthController: 处理登录请求
> AuthController -> JwtUtil: 生成JWT令牌(包含用户信息)
> JwtUtil -> AuthController: 返回JWT令牌
> AuthController -> API网关: 返回包含令牌的响应
> API网关 -> 前端: 返回JWT令牌
> 前端: 保存令牌到localStorage

> **查询逻辑**
>
> 用户 -> 前端: 发起查询请求
> 前端 -> API网关: 请求携带JWT令牌(Authorization头)
> API网关 -> JwtAuthenticationFilter: 拦截并验证令牌
> JwtAuthenticationFilter: 解析令牌获取用户信息，将用户信息添加到自定义请求头
> API网关 -> 费用查询服务: 转发带有用户信息的请求
> 费用查询服务 -> RequestInterceptor: 拦截请求
> RequestInterceptor: 从请求头提取用户信息
> RequestInterceptor -> UserContext: 设置用户信息到线程上下文
> 费用查询服务 -> SettlementController: 处理查询请求
> SettlementController -> SettlementService: 调用业务逻辑
> SettlementService: 从UserContext获取用户信息，根据用户角色应用数据过滤
> SettlementService -> 数据库: 执行带有权限过滤的查询
> 数据库 -> SettlementService: 返回查询结果
> SettlementService -> SettlementController: 返回处理后的数据
> 费用查询服务 -> API网关: 返回响应
> API网关 -> 前端: 返回最终数据

## 2025.05.02

#### API网关服务

- 生产者实现，处理队列消息

#### 费用查询服务

- 门诊监管主页的数据查询（含Redis）

#### 深度分析服务

- 对某天医生的行为进行风险评估，返回三种风险
- 消费者实现，处理队列消息

> **风险评估请求流程**
>
> 用户 -> 前端: 请求医生风险评估
>
> 前端 -> API网关: POST /api/async-risk-assessment/assess (携带doctorId和date参数)
>
> API网关 -> AsyncRiskController: 处理风险评估请求
>
> AsyncRiskController -> RiskAssessmentService: 调用submitRiskAssessment()方法
>
> RiskAssessmentService -> Redis: 记录请求状态为"PENDING"
>
> RiskAssessmentService -> RabbitTemplate: 调用convertAndSend()发送消息到队列
>
> RabbitTemplate -> RabbitMQ: 将消息发送到risk.assessment.exchange交换机
>
> RabbitMQ: 路由消息到risk.assessment.queue队列 
>
> API网关 -> 前端: 返回请求ID (用于后续查询结果)
>
> **风险评估处理流程**
>
> RabbitMQ -> RiskAssessmentConsumer: 从队列接收消息
>
> RiskAssessmentConsumer -> *process_message_with_context(): 处理消息*
>
> process_message_with_context() -> risk_assessment(): 调用风险评估API
>
> risk_assessment() -> 数据库: 查询医生费用、药品和诊断数据
>
> risk_assessment() -> get_models(): 加载风险评估模型
>
> get_models() -> risk_assessment(): 返回评估模型
>
> risk_assessment() -> *process_message_with_context(): 返回风险评估结果*
>
> process_message_with_context() -> *send_result(): 将结果发送到API网关回调地址*
>
> send_result() -> API网关: POST请求到/async-risk-assessment/result
>
> **结果回调和查询流程**
>
> API网关 -> AsyncRiskController: 处理回调请求
>
> AsyncRiskController -> RiskAssessmentService: 调用handleAssessmentResult()方法
>
> RiskAssessmentService -> Redis: 保存评估结果 (替换之前的"PENDING"状态)
>
> 前端 -> API网关: GET /api/async-risk-assessment/status/{requestId}
>
> API网关 -> AsyncRiskController: 处理状态查询请求
>
> AsyncRiskController -> RiskAssessmentService: 调用getAssessmentStatus()方法
>
> RiskAssessmentService -> Redis: 获取请求ID的状态或结果
>
> RiskAssessmentService -> AsyncRiskController: 返回状态或结果数据
>
> AsyncRiskController -> 前端: 返回风险评估结果 (包含三种风险等级)
>
> **错误处理流程**
>
> RiskAssessmentConsumer -> *should_requeue_on_callback_failure(): 判断失败消息是否需要重试*
>
> should_requeue_on_callback_failure() -> RiskAssessmentConsumer: 返回重试决定
>
> RiskAssessmentConsumer -> RabbitMQ: 使用basic_nack重新入队或拒绝消息
>
> RiskAssessmentConsumer -> *send_to_dlq(): 将无法处理的消息发送到死信队列*
>
> 每个组件都有详细的日志记录，便于跟踪整个过程并进行故障排查。

> 问题：Python中消费者无法正常消费 -> 在消息发送前手动进行了JSON序列化（不熟悉Spring AMQP框架），而rabbitTemplate.convertAndSend又会自动进行一次序列化，导致Python无法正确解析消息
>
> 解决：取消手动序列化，直接发送Java对象

## 2025.05.07

#### 数据采集服务

- 使用WebSocket推送数据采集进度

> 用户 -> 前端: 发起WebSocket连接请求
>
> 前端 -> API网关: 建立WebSocket连接 (ws://api-gateway/ws)
>
> API网关 -> WebSocketConfig: 配置STOMP端点，设置消息代理
>
> WebSocketConfig -> 前端: 连接建立成功
>
> 用户 -> 前端: 订阅特定主题 (如 /topic/data-collection)
>
> 前端 -> API网关: SUBSCRIBE /topic/data-collection
>
> API网关 -> WebSocketController: 处理订阅请求
>
> 数据采集服务 -> WebSocketController: 调用convertAndSend()发送进度消息
>
> WebSocketController -> STOMP代理: 将消息发送到 /topic/data-collection
>
> STOMP代理 -> 前端: 推送数据采集进度
>
> 前端 -> 用户: 实时展示进度和检测结果

问题：WebSocket经常断开

解决：系统通过配置10秒间隔的心跳机制，配合前端自动重连

## To Do

完善监管看板，基于STOMP协议实时推送数据采集进度，响应时间量化

RabbitMQ原生机制基于队列维度，无法跨队列或跨集群节点做全局调度，需要在网关层面实现集群与负载均衡，TPS（任务提交成功数量/秒）量化

将服务容器化部署

数据查询服务和深度分析服务实现gRPC通信，（先熟悉手写RPC框架项目）

