{"ast":null,"code":"import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, createCommentVNode as _createCommentVNode, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, createStaticVNode as _createStaticVNode } from \"vue\";\nvar _hoisted_1 = {\n  \"class\": \"data-collection-monitor\"\n};\nvar _hoisted_2 = {\n  \"class\": \"status-cards\"\n};\nvar _hoisted_3 = {\n  \"class\": \"status-card\"\n};\nvar _hoisted_4 = {\n  \"class\": \"card-value\",\n  id: \"processed-count\"\n};\nvar _hoisted_5 = {\n  \"class\": \"status-card\"\n};\nvar _hoisted_6 = {\n  \"class\": \"card-value\",\n  id: \"rule-triggered-count\"\n};\nvar _hoisted_7 = {\n  key: 0,\n  \"class\": \"debug-info\"\n};\nvar _hoisted_8 = {\n  \"class\": \"debug-actions\"\n};\nvar _hoisted_9 = {\n  \"class\": \"button-group\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_el_button = _resolveComponent(\"el-button\");\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_cache[18] || (_cache[18] = _createElementVNode(\"h2\", null, \"数据采集实时监控\", -1 /* HOISTED */)), _createElementVNode(\"div\", _hoisted_2, [_createElementVNode(\"div\", _hoisted_3, [_cache[1] || (_cache[1] = _createElementVNode(\"div\", {\n    \"class\": \"card-title\"\n  }, \"已处理数据\", -1 /* HOISTED */)), _createElementVNode(\"div\", _hoisted_4, _toDisplayString($data.processedCount), 1 /* TEXT */)]), _createElementVNode(\"div\", _hoisted_5, [_cache[2] || (_cache[2] = _createElementVNode(\"div\", {\n    \"class\": \"card-title\"\n  }, \"触发规则数据\", -1 /* HOISTED */)), _createElementVNode(\"div\", _hoisted_6, _toDisplayString($data.ruleTriggeredCount), 1 /* TEXT */)])]), _createCommentVNode(\" 纯HTML计数器，完全脱离Vue \"), _cache[19] || (_cache[19] = _createStaticVNode(\"<div class=\\\"pure-html-counters\\\" data-v-7cb1c206><h3 data-v-7cb1c206>原生HTML计数器(脱离Vue)</h3><div class=\\\"manual-counter\\\" data-v-7cb1c206><div class=\\\"counter-label\\\" data-v-7cb1c206>处理数据:</div><div class=\\\"counter-value\\\" id=\\\"raw-processed\\\" data-v-7cb1c206>0</div></div><div class=\\\"manual-counter\\\" data-v-7cb1c206><div class=\\\"counter-label\\\" data-v-7cb1c206>触发规则:</div><div class=\\\"counter-value\\\" id=\\\"raw-triggered\\\" data-v-7cb1c206>0</div></div></div>\", 1)), $data.showDebug ? (_openBlock(), _createElementBlock(\"div\", _hoisted_7, [_createElementVNode(\"p\", null, [_cache[3] || (_cache[3] = _createElementVNode(\"strong\", null, \"WebSocket状态:\", -1 /* HOISTED */)), _createTextVNode(\" \" + _toDisplayString($data.connected ? '已连接' : '未连接'), 1 /* TEXT */)]), _createElementVNode(\"p\", null, [_cache[4] || (_cache[4] = _createElementVNode(\"strong\", null, \"收到的最后消息:\", -1 /* HOISTED */)), _createTextVNode(\" \" + _toDisplayString($data.lastMessage), 1 /* TEXT */)]), _createElementVNode(\"p\", null, [_cache[5] || (_cache[5] = _createElementVNode(\"strong\", null, \"DOM中计数器值:\", -1 /* HOISTED */)), _createTextVNode(\" processed=\" + _toDisplayString($data.processedCount) + \", triggered=\" + _toDisplayString($data.ruleTriggeredCount), 1 /* TEXT */)]), _createElementVNode(\"div\", _hoisted_8, [_createVNode(_component_el_button, {\n    size: \"small\",\n    onClick: $options.forceRender\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[6] || (_cache[6] = [_createTextVNode(\"强制渲染\")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    size: \"small\",\n    onClick: $options.updateDOM\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[7] || (_cache[7] = [_createTextVNode(\"更新DOM值\")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    size: \"small\",\n    type: \"danger\",\n    onClick: $options.updateDOMDirectly\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[8] || (_cache[8] = [_createTextVNode(\"直接更新DOM\")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    size: \"small\",\n    type: \"warning\",\n    onClick: $options.updateRawCounters\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[9] || (_cache[9] = [_createTextVNode(\"更新原生计数器\")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"])])])) : _createCommentVNode(\"v-if\", true), _createElementVNode(\"div\", _hoisted_9, [_createVNode(_component_el_button, {\n    type: \"primary\",\n    onClick: $options.triggerCollection,\n    loading: $data.loading\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[10] || (_cache[10] = [_createTextVNode(\" 模拟数据采集 \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\", \"loading\"]), _createVNode(_component_el_button, {\n    type: \"info\",\n    onClick: $options.testWebSocket\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[11] || (_cache[11] = [_createTextVNode(\" 测试WebSocket \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    type: \"success\",\n    onClick: $options.getStatus\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[12] || (_cache[12] = [_createTextVNode(\" 刷新状态 \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    type: \"warning\",\n    onClick: $options.testLocalCounter\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[13] || (_cache[13] = [_createTextVNode(\" 测试本地计数 \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    type: \"danger\",\n    onClick: $options.forceIncrement\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[14] || (_cache[14] = [_createTextVNode(\" 强制+1 \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    plain: \"\",\n    onClick: _cache[0] || (_cache[0] = function ($event) {\n      return $data.showDebug = !$data.showDebug;\n    })\n  }, {\n    \"default\": _withCtx(function () {\n      return [_createTextVNode(_toDisplayString($data.showDebug ? '隐藏调试' : '显示调试'), 1 /* TEXT */)];\n    }),\n    _: 1 /* STABLE */\n  }), _createVNode(_component_el_button, {\n    type: \"warning\",\n    onClick: $options.resubscribe\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[15] || (_cache[15] = [_createTextVNode(\" 重新订阅 \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    type: \"success\",\n    onClick: $options.testAllApis\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[16] || (_cache[16] = [_createTextVNode(\" 测试所有API \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"]), _createVNode(_component_el_button, {\n    type: \"danger\",\n    onClick: $options.hardRefresh\n  }, {\n    \"default\": _withCtx(function () {\n      return _cache[17] || (_cache[17] = [_createTextVNode(\" 硬重置 \")]);\n    }),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\"])])]);\n}","map":{"version":3,"names":["id","key","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_hoisted_3","_hoisted_4","_toDisplayString","$data","processedCount","_hoisted_5","_hoisted_6","ruleTriggeredCount","_createCommentVNode","_createStaticVNode","showDebug","_hoisted_7","_createTextVNode","connected","lastMessage","_hoisted_8","_createVNode","_component_el_button","size","onClick","$options","forceRender","_withCtx","_cache","_","updateDOM","type","updateDOMDirectly","updateRawCounters","_hoisted_9","triggerCollection","loading","testWebSocket","getStatus","testLocalCounter","forceIncrement","plain","$event","resubscribe","testAllApis","hardRefresh"],"sources":["D:\\Code\\Project\\Medical Insurance Anti-Fraud System\\frontend\\src\\views\\DataMonitor.vue"],"sourcesContent":["<template>\r\n  <div class=\"data-collection-monitor\">\r\n    <h2>数据采集实时监控</h2>\r\n    <div class=\"status-cards\">\r\n      <div class=\"status-card\">\r\n        <div class=\"card-title\">已处理数据</div>\r\n        <div class=\"card-value\" id=\"processed-count\">{{ processedCount }}</div>\r\n      </div>\r\n      <div class=\"status-card\">\r\n        <div class=\"card-title\">触发规则数据</div>\r\n        <div class=\"card-value\" id=\"rule-triggered-count\">{{ ruleTriggeredCount }}</div>\r\n      </div>\r\n    </div>\r\n    \r\n    <!-- 纯HTML计数器，完全脱离Vue -->\r\n    <div class=\"pure-html-counters\">\r\n      <h3>原生HTML计数器(脱离Vue)</h3>\r\n      <div class=\"manual-counter\">\r\n        <div class=\"counter-label\">处理数据:</div>\r\n        <div class=\"counter-value\" id=\"raw-processed\">0</div>\r\n      </div>\r\n      <div class=\"manual-counter\">\r\n        <div class=\"counter-label\">触发规则:</div>\r\n        <div class=\"counter-value\" id=\"raw-triggered\">0</div>\r\n      </div>\r\n    </div>\r\n    \r\n    <div class=\"debug-info\" v-if=\"showDebug\">\r\n      <p><strong>WebSocket状态:</strong> {{connected ? '已连接' : '未连接'}}</p>\r\n      <p><strong>收到的最后消息:</strong> {{lastMessage}}</p>\r\n      <p><strong>DOM中计数器值:</strong> processed={{processedCount}}, triggered={{ruleTriggeredCount}}</p>\r\n      <div class=\"debug-actions\">\r\n        <el-button size=\"small\" @click=\"forceRender\">强制渲染</el-button>\r\n        <el-button size=\"small\" @click=\"updateDOM\">更新DOM值</el-button>\r\n        <el-button size=\"small\" type=\"danger\" @click=\"updateDOMDirectly\">直接更新DOM</el-button>\r\n        <el-button size=\"small\" type=\"warning\" @click=\"updateRawCounters\">更新原生计数器</el-button>\r\n      </div>\r\n    </div>\r\n    \r\n    <div class=\"button-group\">\r\n      <el-button type=\"primary\" @click=\"triggerCollection\" :loading=\"loading\">\r\n        模拟数据采集\r\n      </el-button>\r\n      <el-button type=\"info\" @click=\"testWebSocket\">\r\n        测试WebSocket\r\n      </el-button>\r\n      <el-button type=\"success\" @click=\"getStatus\">\r\n        刷新状态\r\n      </el-button>\r\n      <el-button type=\"warning\" @click=\"testLocalCounter\">\r\n        测试本地计数\r\n      </el-button>\r\n      <el-button type=\"danger\" @click=\"forceIncrement\">\r\n        强制+1\r\n      </el-button>\r\n      <el-button plain @click=\"showDebug = !showDebug\">\r\n        {{ showDebug ? '隐藏调试' : '显示调试' }}\r\n      </el-button>\r\n      <el-button type=\"warning\" @click=\"resubscribe\">\r\n        重新订阅\r\n      </el-button>\r\n      <el-button type=\"success\" @click=\"testAllApis\">\r\n        测试所有API\r\n      </el-button>\r\n      <el-button type=\"danger\" @click=\"hardRefresh\">\r\n        硬重置\r\n      </el-button>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport SockJS from 'sockjs-client';\r\nimport Stomp from 'webstomp-client';\r\nimport axios from 'axios';\r\n\r\naxios.defaults.baseURL = 'http://localhost:8083'; // 后端服务实际端口\r\n\r\nexport default {\r\n  name: 'DataMonitor',\r\n  data() {\r\n    return {\r\n      processedCount: 0,\r\n      ruleTriggeredCount: 0,\r\n      stompClient: null,\r\n      connected: false,\r\n      loading: false,\r\n      heartbeatTimer: null,\r\n      showDebug: true,\r\n      lastMessage: '无'\r\n    }\r\n  },\r\n  mounted() {\r\n    this.connectWebSocket();\r\n    // 初始获取一次状态\r\n    this.getStatus();\r\n  },\r\n  methods: {\r\n    connectWebSocket() {\r\n      try {\r\n        // 使用完整的URL，确保端口匹配\r\n        const socket = new SockJS('http://localhost:8083/ws-data-collection');\r\n        this.stompClient = Stomp.over(socket);\r\n        \r\n        // 禁用调试日志\r\n        this.stompClient.debug = () => {};\r\n        \r\n        this.stompClient.connect({}, frame => {\r\n          console.log('WebSocket连接成功');\r\n          this.connected = true;\r\n          \r\n          // 订阅状态更新\r\n          this.stompClient.subscribe('/topic/collection-status', response => {\r\n            this.lastMessage = response.body;\r\n            const statusUpdate = JSON.parse(response.body);\r\n            console.log('收到状态更新原始数据:', response.body);\r\n            console.log('收到状态更新JSON解析后:', statusUpdate);\r\n            console.log('当前计数器:', this.processedCount, this.ruleTriggeredCount);\r\n            \r\n            // 直接操作DOM更新计数器显示\r\n            if (statusUpdate && typeof statusUpdate.processedCount !== 'undefined') {\r\n              // 直接更新DOM\r\n              this.updateDOMDirectly(statusUpdate.processedCount, statusUpdate.ruleTriggeredCount);\r\n              // 更新原生HTML计数器\r\n              this.updateRawCounters(statusUpdate.processedCount, statusUpdate.ruleTriggeredCount);\r\n            } else {\r\n              console.error('收到的状态更新格式不正确:', statusUpdate);\r\n            }\r\n          });\r\n          \r\n          // 开始心跳检测\r\n          this.startHeartbeat();\r\n          \r\n        }, error => {\r\n          console.error('WebSocket连接错误:', error);\r\n          this.connected = false;\r\n          \r\n          // 5秒后自动重连\r\n          setTimeout(() => {\r\n            console.log('尝试重新连接WebSocket...');\r\n            this.connectWebSocket();\r\n          }, 5000);\r\n        });\r\n        \r\n      } catch (e) {\r\n        console.error('WebSocket初始化错误:', e);\r\n        this.connected = false;\r\n      }\r\n    },\r\n    \r\n    startHeartbeat() {\r\n      // 每30秒发送一次心跳\r\n      this.heartbeatTimer = setInterval(() => {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n          console.log('发送心跳...');\r\n          this.stompClient.send('/app/heartbeat', JSON.stringify({\r\n            client: 'frontend',\r\n            timestamp: new Date().getTime()\r\n          }));\r\n        } else {\r\n          console.log('WebSocket未连接，停止心跳');\r\n          this.stopHeartbeat();\r\n          this.connectWebSocket();\r\n        }\r\n      }, 30000);\r\n    },\r\n    \r\n    stopHeartbeat() {\r\n      if (this.heartbeatTimer) {\r\n        clearInterval(this.heartbeatTimer);\r\n      }\r\n    },\r\n    triggerCollection() {\r\n      this.loading = true;\r\n      console.log('开始发送数据采集请求...');\r\n      console.log('请求URL:', axios.defaults.baseURL + '/api/data-collection/collect');\r\n      \r\n      // 记录当前时间戳，用于跟踪请求\r\n      const requestTime = new Date().toISOString();\r\n      console.log('请求时间:', requestTime);\r\n      \r\n      // 记录发送前的计数值\r\n      console.log('发送前计数:', this.processedCount, this.ruleTriggeredCount);\r\n      \r\n      axios.post('/api/data-collection/collect')\r\n        .then(response => {\r\n          console.log('数据采集触发成功，响应:', response.data);\r\n          \r\n          // 检查响应中是否包含计数信息\r\n          if (response.data && response.data.counts) {\r\n            console.log('响应中包含计数数据:', response.data.counts);\r\n            \r\n            // 直接更新计数器\r\n            const counts = response.data.counts;\r\n            this.updateRawCounters(counts.processedCount, counts.ruleTriggeredCount);\r\n            this.updateDOMDirectly(counts.processedCount, counts.ruleTriggeredCount);\r\n          }\r\n          \r\n          // 请求成功后，立即获取最新状态\r\n          setTimeout(() => {\r\n            this.getStatus();\r\n          }, 500);\r\n        })\r\n        .catch(error => {\r\n          console.error('数据采集触发失败:', error);\r\n          if (error.response) {\r\n            console.error('错误响应:', error.response.status, error.response.data);\r\n          }\r\n        })\r\n        .finally(() => {\r\n          this.loading = false;\r\n          \r\n          // 无论成功失败，2秒后再次获取状态，确保有最新数据\r\n          setTimeout(() => {\r\n            console.log('延迟获取最新状态...');\r\n            this.getStatus();\r\n          }, 2000);\r\n        });\r\n    },\r\n    getStatus() {\r\n      console.log('获取最新状态...');\r\n      axios.get('/api/data-collection/status')\r\n        .then(response => {\r\n          console.log('获取状态成功:', response.data);\r\n          \r\n          // 获取到的最新状态\r\n          const status = response.data;\r\n          \r\n          // 更新所有计数器\r\n          this.updateRawCounters(status.processedCount, status.ruleTriggeredCount);\r\n          this.updateDOMDirectly(status.processedCount, status.ruleTriggeredCount);\r\n          \r\n          // 同时更新Vue状态\r\n          this.processedCount = isNaN(Number(status.processedCount)) ? 0 : Number(status.processedCount);\r\n          this.ruleTriggeredCount = isNaN(Number(status.ruleTriggeredCount)) ? 0 : Number(status.ruleTriggeredCount);\r\n          this.$forceUpdate();\r\n        })\r\n        .catch(error => {\r\n          console.error('获取状态失败:', error);\r\n        });\r\n    },\r\n    testWebSocket() {\r\n      console.log('测试WebSocket消息...');\r\n      axios.get('/api/data-collection/test-websocket')\r\n        .then(response => {\r\n          console.log('WebSocket测试请求发送成功:', response.data);\r\n        })\r\n        .catch(error => {\r\n          console.error('WebSocket测试请求失败:', error);\r\n        });\r\n    },\r\n    testLocalCounter() {\r\n      console.log('测试本地计数器...');\r\n      this.processedCount += 1;\r\n      this.ruleTriggeredCount += 1;\r\n      console.log('本地计数器已增加到:', this.processedCount, this.ruleTriggeredCount);\r\n    },\r\n    forceIncrement() {\r\n      console.log('发送强制+1请求...');\r\n      // 添加完整URL和检查baseURL\r\n      console.log('完整请求URL:', axios.defaults.baseURL + '/api/data-collection/force-increment');\r\n      axios.get('/api/data-collection/force-increment')\r\n        .then(response => {\r\n          console.log('强制+1请求成功:', response.data);\r\n          // 手动刷新状态，避免依赖WebSocket\r\n          this.getStatus();\r\n        })\r\n        .catch(error => {\r\n          console.error('强制+1请求失败:', error);\r\n          // 添加更多错误信息\r\n          if (error.response) {\r\n            console.error('请求错误状态码:', error.response.status);\r\n            console.error('请求错误详情:', error.response.data);\r\n          }\r\n        });\r\n    },\r\n    resubscribe() {\r\n      if (this.stompClient && this.connected) {\r\n        console.log('重新订阅WebSocket topics');\r\n        // 先取消订阅\r\n        try {\r\n          this.stompClient.unsubscribe('/topic/collection-status');\r\n        } catch (e) {\r\n          console.warn('取消订阅失败:', e);\r\n        }\r\n        \r\n        // 重新订阅\r\n        this.stompClient.subscribe('/topic/collection-status', response => {\r\n          this.lastMessage = response.body;\r\n          const statusUpdate = JSON.parse(response.body);\r\n          console.log('重新订阅后收到状态更新:', statusUpdate);\r\n          \r\n          // 更新计数器 - 使用Vue的$set确保响应式\r\n          this.updateCounters(statusUpdate.processedCount, statusUpdate.ruleTriggeredCount);\r\n        });\r\n        console.log('重新订阅完成');\r\n      } else {\r\n        console.error('WebSocket未连接，无法重新订阅');\r\n        this.connectWebSocket();\r\n      }\r\n    },\r\n    updateCounters(processed, triggered) {\r\n      console.log('手动更新计数器 - 转换前类型:', typeof processed, typeof triggered);\r\n      \r\n      // 确保是整数类型\r\n      processed = parseInt(processed);\r\n      triggered = parseInt(triggered);\r\n      \r\n      console.log('手动更新计数器:', processed, triggered);\r\n      \r\n      // 使用Vue的数据更新方式\r\n      this.$data.processedCount = processed;\r\n      this.$data.ruleTriggeredCount = triggered;\r\n      \r\n      console.log('更新后的数据:', this.$data.processedCount, this.$data.ruleTriggeredCount);\r\n      \r\n      // 多种方式尝试强制更新\r\n      this.$forceUpdate();\r\n      \r\n      // 使用直接DOM更新作为备份\r\n      setTimeout(() => {\r\n        const processedEl = document.querySelector('.status-card:first-child .card-value');\r\n        const triggeredEl = document.querySelector('.status-card:last-child .card-value');\r\n        \r\n        if (processedEl && triggeredEl) {\r\n          processedEl.textContent = processed;\r\n          triggeredEl.textContent = triggered;\r\n          console.log('通过setTimeout直接更新DOM完成');\r\n        }\r\n      }, 50);\r\n    },\r\n    testAllApis() {\r\n      console.log('测试所有已知API...');\r\n      \r\n      // 测试 /status API\r\n      console.log('测试 /api/data-collection/status...');\r\n      axios.get('/api/data-collection/status')\r\n        .then(response => {\r\n          console.log('状态API测试成功:', response.data);\r\n        })\r\n        .catch(error => {\r\n          console.error('状态API测试失败:', error);\r\n        });\r\n      \r\n      // 测试 /test-websocket API\r\n      console.log('测试 /api/data-collection/test-websocket...');\r\n      axios.get('/api/data-collection/test-websocket')\r\n        .then(response => {\r\n          console.log('测试WebSocket API测试成功:', response.data);\r\n        })\r\n        .catch(error => {\r\n          console.error('测试WebSocket API测试失败:', error);\r\n        });\r\n      \r\n      // 测试 /collect API\r\n      console.log('测试 /api/data-collection/collect...');\r\n      axios.post('/api/data-collection/collect')\r\n        .then(response => {\r\n          console.log('采集API测试成功:', response.data);\r\n        })\r\n        .catch(error => {\r\n          console.error('采集API测试失败:', error);\r\n        });\r\n    },\r\n    forceRender() {\r\n      console.log('强制重新渲染视图...');\r\n      this.$forceUpdate();\r\n    },\r\n    \r\n    updateDOM() {\r\n      console.log('强制DOM更新...');\r\n      // 使用jQuery或原生DOM更新元素内容，绕过Vue\r\n      const processedEl = document.querySelector('.status-card:first-child .card-value');\r\n      const triggeredEl = document.querySelector('.status-card:last-child .card-value');\r\n      \r\n      if (processedEl && triggeredEl) {\r\n        processedEl.textContent = this.processedCount;\r\n        triggeredEl.textContent = this.ruleTriggeredCount;\r\n        console.log('直接更新DOM: ', processedEl.textContent, triggeredEl.textContent);\r\n      } else {\r\n        console.error('找不到DOM元素');\r\n      }\r\n    },\r\n    updateDOMDirectly(processed, triggered) {\r\n      console.log('直接更新DOM元素...');\r\n      \r\n      // 如果没有传入参数，使用当前状态\r\n      if (arguments.length === 0) {\r\n        try {\r\n          const lastMessageObj = this.lastMessage ? JSON.parse(this.lastMessage) : {processedCount: 0, ruleTriggeredCount: 0};\r\n          processed = lastMessageObj.processedCount;\r\n          triggered = lastMessageObj.ruleTriggeredCount;\r\n          console.log('从lastMessage解析:', processed, triggered);\r\n        } catch (e) {\r\n          console.error('解析lastMessage失败:', e);\r\n          processed = 0;\r\n          triggered = 0;\r\n        }\r\n      }\r\n      \r\n      // 安全转换为数字，确保即使转换失败也有默认值\r\n      const processedNum = Number(processed);\r\n      const triggeredNum = Number(triggered);\r\n      \r\n      // 检查是否为有效数字，否则使用0\r\n      const safeProcessed = !isNaN(processedNum) ? processedNum : 0;\r\n      const safeTriggered = !isNaN(triggeredNum) ? triggeredNum : 0;\r\n      \r\n      console.log('安全转换后的数字:', safeProcessed, safeTriggered);\r\n      \r\n      // 直接设置DOM内容 - 不使用数字而是字符串以避免NaN\r\n      const processedEl = document.getElementById('processed-count');\r\n      const triggeredEl = document.getElementById('rule-triggered-count');\r\n      \r\n      if (processedEl && triggeredEl) {\r\n        // 绕过Vue直接设置文本内容\r\n        processedEl.textContent = String(safeProcessed);\r\n        triggeredEl.textContent = String(safeTriggered);\r\n        console.log('直接更新DOM完成:', processedEl.textContent, triggeredEl.textContent);\r\n      } else {\r\n        console.error('找不到DOM元素，尝试使用选择器');\r\n        \r\n        // 尝试另一种选择器\r\n        const procEl = document.querySelector('.status-card:first-child .card-value');\r\n        const trigEl = document.querySelector('.status-card:last-child .card-value');\r\n        \r\n        if (procEl && trigEl) {\r\n          procEl.textContent = String(safeProcessed);\r\n          trigEl.textContent = String(safeTriggered);\r\n          console.log('通过选择器更新DOM完成');\r\n        } else {\r\n          console.error('无法找到DOM元素更新');\r\n        }\r\n      }\r\n      \r\n      // 同时更新Vue变量，使用安全值避免NaN\r\n      this.processedCount = safeProcessed;\r\n      this.ruleTriggeredCount = safeTriggered;\r\n      this.$forceUpdate();\r\n      \r\n      // 额外检查数据\r\n      console.log('更新后Vue变量:', this.processedCount, this.ruleTriggeredCount);\r\n    },\r\n    updateRawCounters(processed, triggered) {\r\n      console.log('更新原生HTML计数器...');\r\n      \r\n      // 如果没有传入参数，使用当前状态\r\n      if (arguments.length === 0) {\r\n        try {\r\n          const lastMessageObj = this.lastMessage ? JSON.parse(this.lastMessage) : {processedCount: 0, ruleTriggeredCount: 0};\r\n          processed = lastMessageObj.processedCount;\r\n          triggered = lastMessageObj.ruleTriggeredCount;\r\n        } catch (e) {\r\n          console.error('解析lastMessage失败:', e);\r\n          processed = 0;\r\n          triggered = 0;\r\n        }\r\n      }\r\n      \r\n      // 安全转换\r\n      const safeProcessed = isNaN(Number(processed)) ? 0 : Number(processed);\r\n      const safeTriggered = isNaN(Number(triggered)) ? 0 : Number(triggered);\r\n      \r\n      // 获取原生HTML元素\r\n      const rawProcessedEl = document.getElementById('raw-processed');\r\n      const rawTriggeredEl = document.getElementById('raw-triggered');\r\n      \r\n      if (rawProcessedEl && rawTriggeredEl) {\r\n        // 直接更新内容\r\n        rawProcessedEl.textContent = String(safeProcessed);\r\n        rawTriggeredEl.textContent = String(safeTriggered);\r\n        console.log('原生HTML计数器更新完成:', safeProcessed, safeTriggered);\r\n        \r\n        // 应用一个视觉效果表明更新成功\r\n        rawProcessedEl.style.backgroundColor = '#e6f7ff';\r\n        rawTriggeredEl.style.backgroundColor = '#e6f7ff';\r\n        \r\n        setTimeout(() => {\r\n          rawProcessedEl.style.backgroundColor = '';\r\n          rawTriggeredEl.style.backgroundColor = '';\r\n        }, 500);\r\n      } else {\r\n        console.error('找不到原生HTML计数器元素');\r\n      }\r\n    },\r\n    hardRefresh() {\r\n      console.log('执行硬重置...');\r\n      // 从URL直接获取最新数据并强制更新\r\n      axios.get('/api/data-collection/status')\r\n        .then(response => {\r\n          console.log('获取到最新状态:', response.data);\r\n          \r\n          if (response.data) {\r\n            const proc = response.data.processedCount;\r\n            const trig = response.data.ruleTriggeredCount;\r\n            \r\n            // 使用window对象存储，以防Vue响应式出问题\r\n            window.currentMetrics = {\r\n              processed: proc,\r\n              triggered: trig\r\n            };\r\n            \r\n            // 多种方式更新，避免单一方式失效\r\n            this.processedCount = proc;\r\n            this.ruleTriggeredCount = trig;\r\n            this.$forceUpdate();\r\n            this.updateDOMDirectly(proc, trig);\r\n            \r\n            // 强制浏览器渲染\r\n            setTimeout(() => {\r\n              this.updateDOMDirectly(proc, trig);\r\n            }, 100);\r\n          }\r\n        })\r\n        .catch(error => {\r\n          console.error('硬重置失败:', error);\r\n        });\r\n    }\r\n  },\r\n  beforeUnmount() {\r\n    if (this.stompClient && this.stompClient.connected) {\r\n      this.stompClient.disconnect();\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.data-collection-monitor {\r\n  padding: 20px;\r\n  max-width: 800px;\r\n  margin: 0 auto;\r\n}\r\n.status-cards {\r\n  display: flex;\r\n  gap: 20px;\r\n  margin-bottom: 20px;\r\n}\r\n.status-card {\r\n  flex: 1;\r\n  padding: 20px;\r\n  border-radius: 8px;\r\n  background-color: #f5f7fa;\r\n  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);\r\n  text-align: center;\r\n}\r\n.card-title {\r\n  font-size: 16px;\r\n  color: #606266;\r\n  margin-bottom: 10px;\r\n}\r\n.card-value {\r\n  font-size: 28px;\r\n  font-weight: bold;\r\n  color: #409EFF;\r\n}\r\n.button-group {\r\n  display: flex;\r\n  gap: 10px;\r\n  margin-top: 20px;\r\n}\r\n.debug-info {\r\n  margin: 20px 0;\r\n  padding: 15px;\r\n  background-color: #f8f9fa;\r\n  border-radius: 8px;\r\n  border: 1px solid #ebeef5;\r\n  font-family: monospace;\r\n}\r\n.pure-html-counters {\r\n  margin: 20px 0;\r\n  padding: 15px;\r\n  background-color: #f0f9eb;\r\n  border-radius: 8px;\r\n  border: 1px solid #e1f3d8;\r\n}\r\n.manual-counter {\r\n  display: flex;\r\n  margin: 10px 0;\r\n  align-items: center;\r\n}\r\n.counter-label {\r\n  width: 100px;\r\n  font-weight: bold;\r\n}\r\n.counter-value {\r\n  font-size: 24px;\r\n  font-weight: bold;\r\n  color: #67c23a;\r\n  min-width: 50px;\r\n  text-align: center;\r\n  padding: 5px 10px;\r\n  background-color: #f5f7fa;\r\n  border-radius: 4px;\r\n  transition: background-color 0.3s ease;\r\n}\r\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}